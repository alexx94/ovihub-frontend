import { useState, useEffect, useRef, useCallback } from "react";
import { fetchPaginatedPosts } from "../api/posts";
import type { Post, PostType } from "../types/post.types";

interface UsePaginatedPostsResult {
  posts: Post[];
  currentPage: number;
  isLoading: boolean;
  error: string | null;
  goToNextPage: () => void;
  goToPreviousPage: () => void;
  hasMore: boolean;
}

/**
 * EXPLICAȚIE CACHE:
 * 
 * Folosim useRef pentru cache pentru că:
 * 1. useRef NU provoacă re-render când se modifică
 * 2. Persistă între render-uri (nu se resetează ca let/const)
 * 3. Se resetează automat la unmount sau refresh (cerință respectată)
 * 
 * Structura cache: Map<string, Post[]>
 * Key format: "{type}-{page}" → ex: "News-1", "StudentEvent-2"
 * 
 * Flow-ul:
 * - Când schimbi pagina, verificăm cache ÎNAINTE de fetch
 * - Dacă există în cache → setăm direct posts (fără fetch)
 * - Dacă NU există → fetch + salvare în cache
 */

export const usePaginatedPosts = (
  postType: PostType
): UsePaginatedPostsResult => {
  const [posts, setPosts] = useState<Post[]>([]);
  const [currentPage, setCurrentPage] = useState(1);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [hasMore, setHasMore] = useState(true);

  // Cache storage - persistă între renders, dispare la unmount
  const cacheRef = useRef<Map<string, Post[]>>(new Map());

  // Cache key generator
  const getCacheKey = useCallback(
    (page: number) => `${postType}-${page}`,
    [postType]
  );

  /**
   * EXPLICAȚIE DE CE NU SUNT WARNINGS:
   * 
   * 1. loadPosts este wrappat în useCallback cu dependințe FIXE
   *    - postType vine din props (stabil)
   *    - getCacheKey este useCallback (stabil)
   *    - cacheRef este ref (întotdeauna stabil)
   * 
   * 2. NU modificăm currentPage în loadPosts
   *    - primim page ca parametru
   *    - setăm currentPage DOAR din goToNextPage/goToPreviousPage
   *    - evităm loop-ul: loadPosts → setCurrentPage → useEffect → loadPosts
   * 
   * 3. useEffect are dependințe STABILE:
   *    - currentPage (primitiv)
   *    - loadPosts (useCallback cu deps fixe)
   *    - loadPosts NU se schimbă între renders
   */
  const loadPosts = useCallback(
    async (page: number) => {
      const cacheKey = getCacheKey(page);

      // Verificăm cache ÎNAINTE de orice altceva
      const cachedData = cacheRef.current.get(cacheKey);
      if (cachedData) {
        // CACHE HIT - setăm datele instant, fără fetch
        setPosts(cachedData);
        setError(null);
        return;
      }

      // CACHE MISS - facem fetch
      setIsLoading(true);
      setError(null);

      try {
        const response = await fetchPaginatedPosts({
          type: postType,
          page,
        });

        // Salvăm în cache
        cacheRef.current.set(cacheKey, response.data);

        // Actualizăm state-ul
        setPosts(response.data);

        // Determinăm dacă mai sunt pagini
        // Dacă primim 0 rezultate, înseamnă că nu mai sunt
        setHasMore(response.data.length > 0);
      } catch (err) {
        const errorMessage =
          err instanceof Error ? err.message : "Failed to load posts";
        setError(errorMessage);
        setPosts([]);
        setHasMore(false);
      } finally {
        setIsLoading(false);
      }
    },
    [postType, getCacheKey]
  );

  /**
   * Effect care se declanșează DOAR când:
   * 1. Componenta se montează (inițial)
   * 2. currentPage se schimbă (user navighează)
   * 3. postType se schimbă (switch între News/Events)
   * 
   * loadPosts este STABIL (useCallback) deci nu provoacă re-renders inutile
   */
  useEffect(() => {
    loadPosts(currentPage);
  }, [currentPage, loadPosts]);

  /**
   * Re-evaluate hasMore when posts change
   * Dacă avem posts pe pagina curentă, înseamnă că s-ar putea să existe și pagina următoare
   */
  useEffect(() => {
    if (posts.length > 0) {
      // Dacă suntem pe o pagină cu conținut din cache, verifică dacă există pagina următoare în cache
      const nextPageKey = getCacheKey(currentPage + 1);
      const nextPageInCache = cacheRef.current.has(nextPageKey);
      
      if (nextPageInCache) {
        const nextPagePosts = cacheRef.current.get(nextPageKey);
        // Dacă pagina următoare există în cache și are posts, hasMore = true
        setHasMore((nextPagePosts?.length ?? 0) > 0);
      } else {
        // Dacă pagina următoare nu e în cache, presupunem că ar putea exista
        // (vom afla sigur când user-ul apasă Next)
        setHasMore(true);
      }
    }
  }, [posts, currentPage, getCacheKey]);

  /**
   * Handlers pentru navigație
   * 
   * Acestea sunt singurele locuri unde modificăm currentPage
   * useEffect observă schimbarea și apelează loadPosts
   * 
   * Flow: goToNextPage → setCurrentPage(2) → useEffect vede change → loadPosts(2)
   */
  const goToNextPage = useCallback(() => {
    if (!isLoading && hasMore) {
      setCurrentPage((prev) => prev + 1);
    }
  }, [isLoading, hasMore]);

  const goToPreviousPage = useCallback(() => {
    if (!isLoading && currentPage > 1) {
      setCurrentPage((prev) => prev - 1);
    }
  }, [isLoading, currentPage]);

  /**
   * EXPLICAȚIE RESET CACHE LA SWITCH:
   * 
   * Când postType se schimbă (News → StudentEvent sau invers):
   * 1. loadPosts își schimbă referința (pentru că depinde de postType)
   * 2. useEffect se re-execută
   * 3. Cache-ul rămâne intact (conține și News și StudentEvent)
   * 4. Resetăm pagina la 1 pentru noul tip
   * 
   * Dacă vrei să ștergi cache-ul la switch, poți adăuga:
   * useEffect(() => { 
   *   cacheRef.current.clear(); 
   *   setCurrentPage(1); 
   * }, [postType]);
   */

  return {
    posts,
    currentPage,
    isLoading,
    error,
    goToNextPage,
    goToPreviousPage,
    hasMore,
  };
};